{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n3\\n6\"]",
    "src_uid": "41359a6dbfb0bf0887fef84ac748983a",
    "prob_desc_notes": "NoteIn the first test case, we can pick the whole array as a beautiful subsequence because $$$1 \\oplus 1 &lt; 2 \\oplus 0$$$.In the second test case, we can pick elements with indexes $$$1$$$, $$$2$$$ and $$$4$$$ (in $$$0$$$ indexation). For this elements holds: $$$2 \\oplus 2 &lt; 4 \\oplus 1$$$ and $$$4 \\oplus 4 &lt; 1 \\oplus 2$$$.",
    "prob_desc_description": "It is the hard version of the problem. The only difference is that in this version $$$a_i \\le 10^9$$$.You are given an array of $$$n$$$ integers $$$a_0, a_1, a_2, \\ldots a_{n - 1}$$$. Bryap wants to find the longest beautiful subsequence in the array.An array $$$b = [b_0, b_1, \\ldots, b_{m-1}]$$$, where $$$0 \\le b_0 &lt; b_1 &lt; \\ldots &lt; b_{m - 1} &lt; n$$$, is a subsequence of length $$$m$$$ of the array $$$a$$$.Subsequence $$$b = [b_0, b_1, \\ldots, b_{m-1}]$$$ of length $$$m$$$ is called beautiful, if the following condition holds:   For any $$$p$$$ ($$$0 \\le p &lt; m - 1$$$) holds: $$$a_{b_p} \\oplus b_{p+1} &lt; a_{b_{p+1}} \\oplus b_p$$$. Here $$$a \\oplus b$$$ denotes the bitwise XOR of $$$a$$$ and $$$b$$$. For example, $$$2 \\oplus 4 = 6$$$ and $$$3 \\oplus 1=2$$$.Bryap is a simple person so he only wants to know the length of the longest such subsequence. Help Bryap and find the answer to his question.",
    "prob_desc_output_spec": "For each test case print a single integer — the length of the longest beautiful subsequence.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^5$$$)  — the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$2 \\leq n \\leq 3 \\cdot 10^5$$$) — the length of the array. The second line of each test case contains $$$n$$$ integers $$$a_0,a_1,...,a_{n-1}$$$ ($$$0 \\leq a_i \\leq 10^9$$$) — the elements of the array. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$3 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_098.jsonl",
    "code_uid": "3fd7ba6b51e84c3b8a5e449a8dcd2aed",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n2\\n\\n1 2\\n\\n5\\n\\n5 2 4 3 1\\n\\n10\\n\\n3 8 8 2 9 1 6 2 8 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\ntwopow = []\r\nfor i in range(30):\r\n    twopow.append(2 ** i)\r\ntwopow.reverse()\r\n\r\nmaxN = int(60e6)\r\ntrie = [0] * maxN  # in segments of 6. [l, r, 00, 01, 10, 11]\r\nfor i in range(0, maxN, 6):\r\n    trie[i] = trie[i + 1] = -1  # -1 if not linked to any node\r\n\r\nidx_of_trie = 6\r\ndef get_next_idx_of_trie():\r\n    global idx_of_trie\r\n    idx_of_trie += 6\r\n    return idx_of_trie - 6\r\n\r\ndef clear_trie():\r\n    global idx_of_trie\r\n    temp = idx_of_trie\r\n    \r\n    while idx_of_trie >= 1:\r\n        idx_of_trie -= 1\r\n        trie[idx_of_trie] = 0\r\n    \r\n    for i in range(0, temp, 6):\r\n        trie[i] = trie[i + 1] = -1\r\n    \r\n    idx_of_trie = 6\r\n        \r\n\r\nbitmap = [(1, 0), (0, 0), (1, 1), (0, 1)]\r\n# bitmap[ibit * 2 + aibit] = (jbit, ajbit) where j < i and (aibit ^ jbit) > (ajbit ^ ibit)\r\n\r\ndef main():\r\n    \r\n    def add(i, ai):\r\n        value = i ^ ai\r\n        node = 0\r\n        currmax = 1\r\n        for tp in twopow:\r\n            \r\n            if (i & tp) > 0: ibit = 1\r\n            else: ibit = 0\r\n            if (ai & tp) > 0: aibit = 1\r\n            else: aibit = 0\r\n            \r\n            if (value & tp) > 0:\r\n                if trie[node + 1] == -1:\r\n                    trie[node + 1] = get_next_idx_of_trie()\r\n                neighbour = trie[node]\r\n                node = trie[node + 1]\r\n            else:\r\n                if trie[node] == -1:\r\n                    trie[node] = get_next_idx_of_trie()\r\n                neighbour = trie[node + 1]\r\n                node = trie[node]\r\n            \r\n            if neighbour != -1:\r\n                # ai ^ j == aj ^ i right up to before this node.\r\n                # Need to find max dp for ai ^ j > aj ^ i,\r\n                # where i is current index and j is a previous index.\r\n                # for jbit in range(2):\r\n                #     for ajbit in range(2):\r\n                #         if (aibit ^ jbit) > (ajbit ^ ibit):\r\n                #             currmax = max(currmax, 1 + neighbour.dp[jbit][ajbit])\r\n                    \r\n                # Casework. (aibit ^ jbit) > (ajbit ^ ibit)\r\n                jbit, ajbit = bitmap[ibit * 2 + aibit]\r\n                currmax = max(currmax, 1 + trie[neighbour + 2 + jbit * 2 + ajbit])\r\n        \r\n        # update trie\r\n        node = 0\r\n        for tp in twopow:\r\n            \r\n            if (i & tp) > 0: ibit = 1\r\n            else: ibit = 0\r\n            if (ai & tp) > 0: aibit = 1\r\n            else: aibit = 0\r\n            \r\n            if (value & tp) > 0:\r\n                node = trie[node + 1]\r\n            else:\r\n                node = trie[node]\r\n            \r\n            # node.dp[ibit][aibit] = max(node.dp[ibit][aibit], currmax)\r\n            trie[node + 2 + ibit * 2 + aibit] = max(currmax,\r\n                                                    trie[node + 2 + ibit * 2 + aibit])\r\n        \r\n        return currmax\r\n    \r\n    t = int(input())\r\n    allans = []\r\n    for _ in range(t):\r\n        n = int(input())\r\n        a = readIntArr()\r\n        \r\n        # testdp = [1] * n\r\n        ans = 0\r\n        for i, ai in enumerate(a):\r\n            res = add(i, ai)\r\n            # testdp[i] = res\r\n            ans = max(ans, res)\r\n        \r\n        # print(testdp)  # TEST\r\n        \r\n        allans.append(ans)\r\n        clear_trie()\r\n    multiLineArrayPrint(allans)\r\n    \r\n    return\r\n\r\nimport sys\r\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\r\n \r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n \r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(a, b, c):\r\n    print('? {} {} {}'.format(a, b, c))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(x1, x2):\r\n    print('! {} {}'.format(x1, x2))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\n# MOD=10**9+7\r\n# MOD=998244353\r\n \r\nfrom math import gcd,floor,ceil\r\nimport math\r\n# from math import floor,ceil # for Python2\r\n \r\nfor _abc in range(1):\r\n    main()",
    "prob_desc_created_at": "1660829700",
    "tags": [
        "bitmasks",
        "data structures",
        "dp",
        "strings",
        "trees"
    ],
    "hidden_unit_tests": ""
}