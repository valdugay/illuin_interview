{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1 0 0 1\\n0 1 1 0\\n1 0\\n0 1\\n1 0 1 0\\n0 0 1 1\\n1 1 0 0\\n0 1 0 1\"]",
    "src_uid": "b7d40e7fc4f277cc801b59a21a16dfc1",
    "prob_desc_notes": "NoteWhite means $$$0$$$, black means $$$1$$$. The binary matrix from the first test caseThe binary matrix from the second test caseThe binary matrix from the third test case ",
    "prob_desc_description": "You are given two even integers $$$n$$$ and $$$m$$$. Your task is to find any binary matrix $$$a$$$ with $$$n$$$ rows and $$$m$$$ columns where every cell $$$(i,j)$$$ has exactly two neighbours with a different value than $$$a_{i,j}$$$.Two cells in the matrix are considered neighbours if and only if they share a side. More formally, the neighbours of cell $$$(x,y)$$$ are: $$$(x-1,y)$$$, $$$(x,y+1)$$$, $$$(x+1,y)$$$ and $$$(x,y-1)$$$.It can be proven that under the given constraints, an answer always exists.",
    "prob_desc_output_spec": "For each test case, print $$$n$$$ lines, each of which contains $$$m$$$ numbers, equal to $$$0$$$ or $$$1$$$ — any binary matrix which satisfies the constraints described in the statement. It can be proven that under the given constraints, an answer always exists.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line of input contains a single integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of test cases. The following lines contain the descriptions of the test cases. The only line of each test case contains two even integers $$$n$$$ and $$$m$$$ ($$$2 \\le n,m \\le 50$$$) — the height and width of the binary matrix, respectively.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 900,
    "file_name": "train_088.jsonl",
    "code_uid": "ffac19dd5607133004555ed2cbfca103",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n2 4\\n\\n2 2\\n\\n4 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "t = int(input())\r\nwhile (t > 0):\r\n    lst = list(map(int, input().split()))[:2]\r\n    if (lst[0] == 2):\r\n        if ((lst[1] // 2) % 2 == 0):\r\n            print(\"1 0 0 1 \" * (lst[1] // 4))\r\n            print(\"0 1 1 0 \" * (lst[1] // 4))\r\n        else:\r\n            print(\"1 0 0 1 \" * (lst[1] // 4) + \"1 0 \")\r\n            print(\"0 1 1 0 \" * (lst[1] // 4) + \"0 1 \")\r\n    else:\r\n        if ((lst[1] // 2) % 2 == 0):\r\n            x = 0\r\n            print(\"1 0 0 1 \" * (lst[1] // 4) )\r\n            while (x < ((lst[0] - 2) // 2)):\r\n                if (x % 2 == 0):\r\n                    print(\"0 1 1 0 \" * (lst[1] // 4))\r\n                    print(\"0 1 1 0 \" * (lst[1] // 4) )\r\n                    x += 1\r\n                else:\r\n                    print(\"1 0 0 1 \" * (lst[1] // 4) )\r\n                    print(\"1 0 0 1 \" * (lst[1] // 4) )\r\n                    x += 1\r\n\r\n            if (((lst[0] - 2) // 2) % 2 == 0):\r\n                print(\"0 1 1 0 \" * (lst[1] // 4))\r\n            else:\r\n                print(\"1 0 0 1 \" * (lst[1] // 4))\r\n\r\n        else:\r\n\r\n         x = 0\r\n         print(\"1 0 0 1 \" * (lst[1] // 4) + \"1 0 \")\r\n         while (x < ((lst[0] - 2) // 2)):\r\n            if (x % 2 == 0):\r\n                print(\"0 1 1 0 \" * (lst[1] // 4) + \"0 1 \")\r\n                print(\"0 1 1 0 \" * (lst[1] // 4) + \"0 1 \")\r\n                x += 1\r\n            else:\r\n                print(\"1 0 0 1 \" * (lst[1] // 4) + \"1 0 \")\r\n                print(\"1 0 0 1 \" * (lst[1] // 4) + \"1 0 \")\r\n                x += 1\r\n\r\n         if (((lst[0] - 2) // 2) % 2 == 0):\r\n            print(\"0 1 1 0 \" * (lst[1] // 4) + \"0 1 \")\r\n         else:\r\n            print(\"1 0 0 1 \" * (lst[1] // 4) + \"1 0 \")\r\n\r\n    t -= 1\r\n",
    "prob_desc_created_at": "1656945300",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "matrices"
    ],
    "hidden_unit_tests": ""
}